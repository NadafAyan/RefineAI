"use client";

import { useState } from "react";
import {
    Category,
    Model,
    OutputFormat,
    getPersonaSuggestions,
    getPlaceholder,
    ALL_MODELS,
    CATEGORIES,
} from "@/lib/wizard-data";

interface WizardState {
    selectedCategory: Category | null;
    objective: string;
    persona: string;
    targetModel: Model | null;
    format: OutputFormat;
    tone: number; // 0-100
    refinedOutput: string;
}

interface UsePromptWizardReturn {
    currentStep: number;
    state: WizardState;
    isGenerating: boolean;
    nextStep: () => void;
    prevStep: () => void;
    selectCategory: (category: Category) => void;
    updateField: <K extends keyof WizardState>(field: K, value: WizardState[K]) => void;
    getPersonaSuggestions: () => string[];
    getPlaceholderText: () => string;
    generatePrompt: () => Promise<void>;
    loadFromParams: (params: URLSearchParams) => void;
    loadFromTemplate: (templateData: any) => void;
    resetWizard: () => void;
}

const initialState: WizardState = {
    selectedCategory: null,
    objective: "",
    persona: "",
    targetModel: ALL_MODELS[0], // Default to GPT-4o
    format: "Markdown",
    tone: 50,
    refinedOutput: "",
};

export function usePromptWizard(): UsePromptWizardReturn {
    const [currentStep, setCurrentStep] = useState(1);
    const [state, setState] = useState<WizardState>(initialState);
    const [isGenerating, setIsGenerating] = useState(false);

    const selectCategory = (category: Category) => {
        setState((prev) => ({ ...prev, selectedCategory: category }));
        // Auto-advance to step 2
        setCurrentStep(2);
    };

    const nextStep = () => {
        if (currentStep < 4) {
            setCurrentStep((prev) => prev + 1);
        }
    };

    const prevStep = () => {
        if (currentStep > 1) {
            setCurrentStep((prev) => prev - 1);
        }
    };

    const updateField = <K extends keyof WizardState>(
        field: K,
        value: WizardState[K]
    ) => {
        setState((prev) => ({ ...prev, [field]: value }));
    };

    const getCurrentPersonaSuggestions = (): string[] => {
        if (!state.selectedCategory) return [];
        return getPersonaSuggestions(state.selectedCategory.id);
    };

    const getPlaceholderTextForCategory = (): string => {
        if (!state.selectedCategory) return "Describe what you need help with...";
        return getPlaceholder(state.selectedCategory.id);
    };

    const generatePrompt = async () => {
        setIsGenerating(true);

        // Simulate API call delay (replace with actual API call later)
        await new Promise(resolve => setTimeout(resolve, 2000));

        try {
            // TODO: Replace with actual AI API call
            // Example: const response = await fetch('/api/generate-prompt', { 
            //   method: 'POST',
            //   body: JSON.stringify({ category, objective, persona, model, format, tone })
            // });

            const toneDescription =
                state.tone < 33
                    ? "casual and friendly"
                    : state.tone > 66
                        ? "academic and strict"
                        : "professional and balanced";

            const categoryLabel = state.selectedCategory?.label || "general assistance";

            const refinedPrompt = `# Refined ${categoryLabel} Prompt for ${state.targetModel?.name}

## Role Assignment
You are acting as: **${state.persona || "an expert assistant"}**

## Primary Objective
${state.objective || "No objective specified yet."}

## Context & Domain
This is a **${categoryLabel}** task. Approach this with domain-specific knowledge and best practices.

## Output Requirements
- **Format**: ${state.format}
- **Tone**: ${toneDescription}
- **Target Model**: Optimized for ${state.targetModel?.name || "AI model"}

## Instructions
1. Carefully analyze the objective in the context of ${categoryLabel}
2. Provide a comprehensive, ${toneDescription} response
3. Structure your output according to the **${state.format}** format specification
4. Maintain consistency with ${state.targetModel?.name}'s capabilities and strengths
5. Incorporate domain-specific terminology and frameworks relevant to ${categoryLabel}

## Quality Criteria
- Clear, actionable, and well-structured guidance
- Appropriate level of technical depth for ${categoryLabel}
- ${toneDescription.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')} communication style
- Adherence to ${state.format} formatting standards

## Success Metrics
- Task completion aligns with stated objective
- Output demonstrates expert-level understanding of ${categoryLabel}
- Communication style matches the requested ${toneDescription} tone

---
*Generated by RefineAI - Smart Prompt Engineering*
*Category: ${categoryLabel} | Model: ${state.targetModel?.name} | Format: ${state.format}*`;

            setState((prev) => ({ ...prev, refinedOutput: refinedPrompt }));
        } catch (error) {
            console.error("Error generating prompt:", error);
            // Handle error appropriately
        } finally {
            setIsGenerating(false);
        }
    };

    const loadFromParams = (params: URLSearchParams) => {
        const categoryId = params.get('category');
        const objective = params.get('objective');
        const persona = params.get('persona');
        const modelName = params.get('model');
        const format = params.get('format');
        const tone = params.get('tone');

        if (categoryId && objective) {
            // Import CATEGORIES to find the matching category
            const { CATEGORIES } = require('@/lib/wizard-data');
            const category = CATEGORIES.find((c: Category) => c.id === categoryId);

            if (category) {
                setState((prev) => ({
                    ...prev,
                    selectedCategory: category,
                    objective: objective || '',
                    persona: persona || '',
                    targetModel: ALL_MODELS.find(m => m.name === modelName) || ALL_MODELS[0],
                    format: (format as OutputFormat) || 'Markdown',
                    tone: tone ? parseInt(tone) : 50,
                }));
                // Start at step 2 since category is already selected
                setCurrentStep(2);
            }
        }
    };

    const loadFromTemplate = (templateData: any) => {
        if (!templateData) return;

        const category = CATEGORIES.find(c => c.id === templateData.category);
        if (!category) return;

        const model = ALL_MODELS.find(m => m.name === templateData.constraints.model);

        setState((prev) => ({
            ...prev,
            selectedCategory: category,
            persona: templateData.persona || '',
            targetModel: model || ALL_MODELS[0],
            format: (templateData.constraints.format as OutputFormat) || 'Markdown',
            tone: templateData.constraints.tone || 50,
            objective: '', // IMPORTANT: Leave empty for fresh input
            refinedOutput: '',
        }));

        // Auto-navigate to Step 2 (Brain Dump) so user can type new objective
        setCurrentStep(2);
    };

    const resetWizard = () => {
        setCurrentStep(1);
        setState(initialState);
    };

    return {
        currentStep,
        state,
        isGenerating,
        nextStep,
        prevStep,
        selectCategory,
        updateField,
        getPersonaSuggestions: getCurrentPersonaSuggestions,
        getPlaceholderText: getPlaceholderTextForCategory,
        generatePrompt,
        loadFromParams,
        loadFromTemplate,
        resetWizard,
    };
}
